function [modulation, carrier, control] = ThreeLevel_ANPC_SVM(obj, load, phaseshift, order, options)
arguments
    obj, load, phaseshift (1, 1) double
    order (1, :) {mustBeNonnegative, mustBeInteger} = [1 2 3 4 5 6]
    options.DisplayMode (1, 1) string {mustBeMember(options.DisplayMode, {'Yes', 'No'})} = 'No'
end

t = 0:obj.Ts:obj.Period;
t_bias = round(t./obj.Ts);
t_bias = floor(t_bias.*load.freq.*obj.Ts) ./ load.freq;
theta = 2.*pi./load.T.*t_bias - phaseshift;
theta = mod(theta-1e-3, 2*pi) + 1e-3;
ma = load.ma * sqrt(3) / 2;
Vref = ma / sqrt(3);
% V1 V2 V3是用来判断大扇区中的小扇区的
theta_inSector = mod(theta-1e-3, pi/3) + 1e-3;
V1 = Vref .* (cos(theta_inSector) - sin(theta_inSector)./sqrt(3));
V2 = 2 .* Vref .* sin(theta_inSector) ./ sqrt(3);
V3 = V1 + V2;
SmallSector1 = (V1<=1/3) & (V2<=1/3) & (V3<=1/3);
SmallSector2 = (V1<=1/3) & (V2<=1/3) & (V3>1/3);
SmallSector3 = (V1>1/3);
SmallSector4 = (V2>1/3);
T1 = SmallSector1 .* 2 .* ma .* sin(pi/3-theta_inSector) ...
    + SmallSector2 .* (1 - 2 .* ma .* sin(theta_inSector)) ...
    + SmallSector3 .* (2 - 2 .* ma .* sin(pi/3+theta_inSector)) ...
    + SmallSector4 .* (2 .* ma .* sin(theta_inSector) - 1);
T2 = SmallSector1 .* (1 - 2 .* ma .* sin(pi/3+theta_inSector)) ...
    + SmallSector2 .* (2 .* ma .* sin(pi/3+theta_inSector) - 1) ...
    + SmallSector3 .* 2 .* ma .* sin(theta_inSector) ...
    + SmallSector4 .* 2 .* ma .* sin(pi/3-theta_inSector);
T3 = SmallSector1 .* 2 .* ma .* sin(theta_inSector) ...
    + SmallSector2 .* (1 - 2 .* ma .* sin(pi/3-theta_inSector)) ...
    + SmallSector3 .* (2 .* ma .* sin(pi/3-theta_inSector) - 1) ...
    + SmallSector4 .* (2 - 2 .* ma .* sin(pi/3+theta_inSector));
% 计算调制波波形
% 第一个modulation波形计算的为处于小扇区1时的调制波, 也是基准值
modulation = (theta<=pi/6+1e-8) .* T1 ./ 2 ...
    + (theta>pi/6+1e-8 & theta<=pi/3+1e-8) .* (T3 ./ 2 + T1) ...
    + (theta>pi/3+1e-8 & theta<=pi/2+1e-8) .* T1 ./ 2 ...
    + (theta>pi/2+1e-8 & theta<=2*pi/3+1e-8) .* (-T3 ./ 2) ...
    + (theta>2*pi/3+1e-8 & theta<=5*pi/6+1e-8) .* (-T1 ./ 2 - T3) ...
    + (theta>5*pi/6+1e-8 & theta<=pi+1e-8) .* (-T3 ./ 2) ...
    + (theta>pi+1e-8 & theta<=7*pi/6+1e-8) .* (-T1 ./ 2) ...
    + (theta>7*pi/6+1e-8 & theta<=4*pi/3+1e-8) .* (-T3 ./ 2 - T1) ...
    + (theta>4*pi/3+1e-8 & theta<=3*pi/2+1e-8) .* (-T1 ./ 2) ...
    + (theta>3*pi/2+1e-8 & theta<=5*pi/3+1e-8) .* T3 ./ 2 ...
    + (theta>5*pi/3+1e-8 & theta<=11*pi/6+1e-8) .* (T1 ./ 2 + T3) ...
    + (theta>11*pi/6+1e-8 & theta<=2*pi+1e-8) .* T3 ./ 2;
% 经过观察规律得, 小扇区2中的调制波可由第一个modulation调制波加上某些数得到
modulation = modulation + ((theta<=pi/3+1e-8 | (theta>5*pi/3+1e-8 & theta<=2*pi+1e-8)) & ...
    (SmallSector2 | SmallSector3 | SmallSector4)) .* T2 ...
    - ((theta>2*pi/3+1e-8 & theta<=4*pi/3+1e-8) & (SmallSector2 | SmallSector3 | SmallSector4)) .* T2;
% 同理计算得到小扇区3和4中的调制波
modulation = modulation + ((theta<=pi/6+1e-8 | (theta>pi/3+1e-8 & theta<=pi/2+1e-8)) & SmallSector3) .* T3 ...
    - (((theta>pi+1e-8 & theta<=7*pi/6+1e-8) | (theta>4*pi/3+1e-8 & theta<=3*pi/2+1e-8)) & SmallSector3) .* T3 ...
    - (((theta>pi/2+1e-8 & theta<=2*pi/3+1e-8) | (theta>5*pi/6+1e-8 & theta<=pi+1e-8)) & SmallSector4) .* T1 ...
    + (((theta>3*pi/2+1e-8 & theta<=5*pi/3+1e-8) | (theta>11*pi/6+1e-8 & theta<=2*pi+1e-8)) & SmallSector4) .* T1;

shift_modulation = zeros(size(modulation));
shift_modulation(1:end-1) = circshift(modulation(1:end-1), round(1/load.freq/obj.Ts));
shift_modulation(end) = modulation(end-round(1/load.freq/obj.Ts));
carrier = zeros(2, length(t));
carrier(1, :) = (rem(t.*load.freq, 1)<1/2) .* 2 .* rem(t.*load.freq, 1) ...
    + (rem(t.*load.freq, 1)>=1/2) .* (2-2.*rem(t.*load.freq, 1));
carrier(2, :) = carrier(1, :) - 1;
control = zeros(6, length(t));
% 为了区别 modulation == 0 的情况
% 直接用 modulation >= 0 来判断会使正半周期大于负半周期
% 精确到小数点后10位
control(1, :) = (modulation >= 1e-10) ...
    | (modulation<1e-10 & modulation>-1e-10 & shift_modulation<-1e-10);
control(4, :) = ~control(1, :);
control(5, :) = control(4, :);
control(6, :) = control(1, :);
control(2, :) = (control(1, :) & modulation >= carrier(1, :)) ...
                    | (control(4, :) & modulation >= carrier(2, :));
control(3, :) = ~control(2, :);
if strcmp(options.DisplayMode, 'No')
    obj.Control(order, :) = control;
    obj.ControlSet(order, :) = 1;
end
end